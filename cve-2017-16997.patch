From ddf9809f60e1656a0c95eed606be184662a3506a Mon Sep 17 00:00:00 2001
From: Victor Rodriguez <victor.rodriguez.bahena@intel.com>
Date: Mon, 8 Jan 2018 00:50:27 +0000
Subject: [PATCH] elf: Check for empty tokens before dynamic string token
 expansion [BZ #22625]

Rebase from commit :

    3e3c904daef69b8bf7d5cc07f793c9f07c3553ef

https://sourceware.org/bugzilla/show_bug.cgi?id=22625

The fillin_rpath function in elf/dl-load.c loops over each RPATH or
RUNPATH tokens and interprets empty tokens as the current directory
("./"). In practice the check for empty token is done *after* the
dynamic string token expansion. The expansion process can return an
empty string for the $ORIGIN token if __libc_enable_secure is set
or if the path of the binary can not be determined (/proc not mounted).

Fix that by moving the check for empty tokens before the dynamic string
token expansion. In addition, check for NULL pointer or empty strings
return by expand_dynamic_string_token.

The above changes highlighted a bug in decompose_rpath, an empty array
is represented by the first element being NULL at the fillin_rpath
level, but by using a -1 pointer in decompose_rpath and other functions.

From: Aurelien Jarno <aurelien@aurel32.net>
---
 elf/dl-load.c | 37 +++++++++++++++++++++++++++----------
 1 file changed, 27 insertions(+), 10 deletions(-)

diff --git a/elf/dl-load.c b/elf/dl-load.c
index c1b6d4b..32bb098 100644
--- a/elf/dl-load.c
+++ b/elf/dl-load.c
@@ -433,23 +433,31 @@ fillin_rpath (char *rpath, struct r_search_path_elem **result, const char *sep,
 {
   char *cp;
   size_t nelems = 0;
-  char *to_free;
 
   while ((cp = __strsep (&rpath, sep)) != NULL)
     {
       struct r_search_path_elem *dirp;
+      char *to_free = NULL;
+      size_t len = 0;
 
-      to_free = cp = expand_dynamic_string_token (l, cp, 1);
+    /* `strsep' can pass an empty string.  */
+    if (*cp != '\0')
+    {
+        to_free = cp = expand_dynamic_string_token (l, cp,1);
 
-      size_t len = strlen (cp);
+    /* expand_dynamic_string_token can return NULL in case of empty
+       path or memory allocation failure.  */
+    if (cp == NULL)
+      continue;
 
-      /* `strsep' can pass an empty string.  This has to be
-	 interpreted as `use the current directory'. */
-      if (len == 0)
-	{
-	  static const char curwd[] = "./";
-	  cp = (char *) curwd;
-	}
+    /* Compute the length after dynamic string token expansion and
+       ignore empty paths.  */
+    len = strlen (cp);
+    if (len == 0)
+      {
+        free (to_free);
+        continue;
+      }
 
       /* Remove trailing slashes (except for "/").  */
       while (len > 1 && cp[len - 1] == '/')
@@ -459,6 +467,7 @@ fillin_rpath (char *rpath, struct r_search_path_elem **result, const char *sep,
       if (len > 0 && cp[len - 1] != '/')
 	cp[len++] = '/';
 
+    }
       /* Make sure we don't use untrusted directories if we run SUID.  */
       if (__glibc_unlikely (check_trusted) && !is_trusted_path (cp, len))
 	{
@@ -621,6 +630,14 @@ decompose_rpath (struct r_search_path_struct *sps,
      necessary.  */
   free (copy);
 
+     /* There is no path after expansion.  */
+     if (result[0] == NULL)
+       {
+         free (result);
+         sps->dirs = (struct r_search_path_elem **) -1;
+         return false;
+       }
+
   sps->dirs = result;
   /* The caller will change this value if we haven't used a real malloc.  */
   sps->malloced = 1;
-- 
2.15.1

